{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-12-12T04:41:15.969Z","updated":"2018-12-12T04:41:15.969Z","comments":true,"path":"hello-world.html","permalink":"http://yoursite.com/hello-world.html","excerpt":"","text":"服务网关zuul ==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M3==示例代码-码云 https://gitee.com/sharps/springcloud前面的文章我们介绍了，Eureka用于服务的注册于发现，Feign支持服务的调用以及均衡负载，Hystrix处理服务的熔断防止故障扩散，Spring Cloud Config服务集群配置中心，似乎一个微服务框架已经完成了。 我们还是少考虑了一个问题，外部的应用如何来访问内部各种各样的微服务呢？在微服务架构中，后端服务往往不直接开放给调用端，而是通过一个API网关根据请求的url，路由到相应的服务。当添加API网关后，在第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务端。 为什么需要API Gateway1、简化客户端调用复杂度 在微服务架构模式下后端服务的实例数一般是动态的，对于客户端而言很难发现动态改变的服务实例的访问地址信息。因此在基于微服务的项目中为了简化前端的调用逻辑，通常会引入API Gateway作为轻量级网关，同时API Gateway中也会实现相关的认证逻辑从而简化内部服务之间相互调用的复杂度。2、数据裁剪以及聚合通常而言不同的客户端对于显示时对于数据的需求是不一致的，比如手机端或者Web端又或者在低延迟的网络环境或者高延迟的网络环境。因此为了优化客户端的使用体验，API Gateway可以对通用性的响应数据进行裁剪以适应不同客户端的使用需求。同时还可以将多个API调用逻辑进行聚合，从而减少客户端的请求数，优化客户端用户体验3、多渠道支持当然我们还可以针对不同的渠道和客户端提供不同的API Gateway,对于该模式的使用由另外一个大家熟知的方式叫Backend for front-end, 在Backend for front-end模式当中，我们可以针对不同的客户端分别创建其BFF，进一步了解BFF可以参考这篇文章：Pattern: Backends For Frontends4、遗留系统的微服务化改造 对于系统而言进行微服务改造通常是由于原有的系统存在或多或少的问题，比如技术债务，代码质量，可维护性，可扩展性等等。API Gateway的模式同样适用于这一类遗留系统的改造，通过微服务化的改造逐步实现对原有系统中的问题的修复，从而提升对于原有业务响应力的提升。通过引入抽象层，逐步使用新的实现替换旧的实现。==在Spring Cloud体系中， Spring Cloud Zuul就是提供负载均衡、反向代理、权限认证的一个API gateway。== Spring Cloud ZuulSpring Cloud Zuul路由是微服务架构的不可或缺的一部分，提供动态路由，监控，弹性，安全等的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。 下面我们通过代码来了解Zuul是如何工作的 简单使用0901gateway-service-zuul-simple 1、添加依赖==org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; ==springboot2.0.0以上版本：引入spring-cloud-starter-netflix-zuul包springboot1.0.0版本：引入spring-cloud-starter-zuul包== 2、配置文件12345678spring.application.name=gateway-service-zuulserver.port=8888#这里的配置表示，访问/redis/** 直接重定向到http://www.xinhuanet.com/**zuul.routes.xinhuanet.path=/redis/**zuul.routes.xinhuanet.url=http://www.xinhuanet.com/zuul.routes.hello.path=/hello/**zuul.routes.hello.url=http://localhost:9000/ 3、启动类12345678@SpringBootApplication@EnableZuulProxypublic class GatewayServiceZuulSimpleApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayServiceZuulSimpleApplication.class, args); &#125;&#125; 启动类添加@EnableZuulProxy，支持网关路由。 史上最简单的zuul案例就配置完了 4、测试启动0901gateway-service-zuul-simple项目，在浏览器中访问：http://localhost:8888/redis/ ，看到页面返回了：http://www.xinhuanet.com/ 页面的信息. 启动spring-cloud-producer为例来测试请求的重定向，在配置文件中添加：12zuul.routes.hello.path=/hello/**zuul.routes.hello.url=http://localhost:9000/ 启动spring-cloud-producer，重新启动gateway-service-zuul-simple，访问：http://localhost:8888/hello/hello?name=llx，返回：hello llx，this is first messge 说明访问gateway-service-zuul-simple的请求自动转发到了spring-cloud-producer，并且将结果返回。 服务化通过url映射的方式来实现zull的转发有局限性，比如每增加一个服务就需要配置一条内容，另外后端的服务如果是动态来提供，就不能采用这种方案来配置了。实际上在实现微服务架构时，服务名与服务实例地址的关系在eureka server中已经存在了，所以只需要将Zuul注册到eureka server上去发现其他服务，就可以实现对serviceId的映射。 启动0903spring-cloud-eureka服务注册中心新建项目0905gateway-service-zuul-eureka。 1、添加依赖12345678910111213&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 添加对eureka的支持==springboot2.0.0以上版本：增加spring-cloud-starter-netflix-eureka-client包springboot1.0.0以上版本：增加spring-cloud-starter-eureka包。== 2、配置文件 配置修改为：1234567spring.application.name=gateway-service-zuulserver.port=8888zuul.routes.api-a.path=/producer/**zuul.routes.api-a.serviceId=spring-cloud-producereureka.client.serviceUrl.defaultZone=http://localhost:8000/eureka/ 3、测试 依次启动 spring-cloud-eureka、 spring-cloud-producer、gateway-service-zuul-eureka，访问：http://localhost:8888/producer/hello?name=llx，返回：hello llx，this is first messge 说明访问gateway-service-zuul-eureka的请求自动转发到了spring-cloud-producer，并且将结果返回。 为了更好的模拟服务集群，我们复制spring-cloud-producer项目改为spring-cloud-producer-2，修改spring-cloud-producer-2项目端口为9001，controller代码修改如下： @RestControllerpublic class HelloController { @RequestMapping(&quot;/hello&quot;) public String index(@RequestParam String name) { return &quot;hello &quot;+name+&quot;，this is two messge&quot;; } }修改完成后启动spring-cloud-producer-2，重启gateway-service-zuul-eureka。测试多次访问http://localhost:8888/producer/hello?name=llx，依次返回： hello llx，this is first messgehello llx，this is two messgehello llx，this is first messgehello llx，this is two messge…说明通过zuul成功调用了producer服务并且做了均衡负载。 网关的默认路由规则但是如果后端服务多达十几个的时候，每一个都这样配置也挺麻烦的，spring cloud zuul已经帮我们做了默认配置。默认情况下，Zuul会代理所有注册到Eureka Server的微服务，并且Zuul的路由规则如下：http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/**会被转发到serviceId对应的微服务。 我们注销掉gateway-service-zuul-eureka项目中关于路由的配置： #zuul.routes.api-a.path=/producer/** #zuul.routes.api-a.serviceId=spring-cloud-producer重新启动后，访问http://localhost:8888/spring-cloud-producer/hello?name=llx，测试返回结果和上述示例相同，说明Spring cloud zuul默认已经提供了转发功能。 到此zuul的基本使用我们就介绍完了。关于zuul更高级使用，我们下篇再来介绍。 09gateway-service-zuul项目节点09gateway-service-zuul—-&gt;0901gateway-service-zuul-simple—-&gt;0902spring-cloud-producer—-&gt;0903spring-cloud-eureka—-&gt;0904spring-cloud-producer-2—-&gt;0905gateway-service-zuul-eureka"}],"posts":[{"title":"springclou学习开篇：从传统架构到微服务架构","slug":"SpringCloud/springcloud-main","date":"2018-10-29T07:13:37.000Z","updated":"2018-12-13T08:19:25.815Z","comments":true,"path":"2018/10/29/SpringCloud/springcloud-main/","link":"","permalink":"http://yoursite.com/2018/10/29/SpringCloud/springcloud-main/","excerpt":"传统架构发展史单体架构单体架构在小微企业比较常见，典型代表就是一个应用、一个数据库、一个web容器就可以跑起来，比如我们开发的开源软件云收藏，就是标准的单体架构。 在两种情况下可能会选择单体架构：一是在企业发展的初期，为了保证快速上线，采用此种方案较为简单灵活；二是传统企业中垂直度较高，访问压力较小的业务。在这种模式下对技术要求较低，方便各层次开发人员接手，也能满足客户需求。 下面是单体架构的架构图：","text":"传统架构发展史单体架构单体架构在小微企业比较常见，典型代表就是一个应用、一个数据库、一个web容器就可以跑起来，比如我们开发的开源软件云收藏，就是标准的单体架构。 在两种情况下可能会选择单体架构：一是在企业发展的初期，为了保证快速上线，采用此种方案较为简单灵活；二是传统企业中垂直度较高，访问压力较小的业务。在这种模式下对技术要求较低，方便各层次开发人员接手，也能满足客户需求。 下面是单体架构的架构图： 在单体架构中，技术选型非常灵活，优先满足快速上线的要求，也便于快速跟进市场。 垂直架构在单体架构发展一段时间后，公司的业务模式得到了认可，交易量也慢慢的大起来，这时候有些企业为了应对更大的流量，就会对原有的业务进行拆分，比如说：后台系统、前端系统、交易系统等。 在这一阶段往往会将系统分为不同的层级，每个层级有对应的职责，UI层负责和用户进行交互、业务逻辑层负责具体的业务功能、数据库层负责和上层进行数据交换和存储。 下面是垂直架构的架构图：在这个阶段SSH（struts+spring+hibernate）是项目的关键技术，Struts负责web层逻辑控制、Spring负责业务层管理Bean、Hibernate负责数据库操作进行封装，持久化数据。 服务化架构如果公司进一步的做大，垂直子系统会变的越来越多，系统和系统之间的调用关系呈指数上升的趋势。在这样的背景下，很多公司都会考虑服务的SOA化。SOA代表面向服务的架构，将应用程序根据不同的职责划分为不同的模块，不同的模块直接通过特定的协议和接口进行交互。这样使整个系统切分成很多单个组件服务来完成请求，当流量过大时通过水平扩展相应的组件来支撑，所有的组件通过交互来满足整体的业务需求。 SOA服务化的优点是，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。服务层是SOA的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。 服务化架构是一套松耦合的架构，服务的拆分原则是服务内部高内聚，服务之间低耦合。 下面是服务化架构图： 在这个阶段可以使用WebService或者dubbo来服务治理。 我们发现从单体架构到服务化架构，应用数量都在不断的增加，慢慢的下沉的就成了基础组建，上浮的就成为业务系统。从上述也可以看出架构的本质就是不断的拆分重构：分的过程是把系统拆分为各个子系统/模块/组件，拆的时候，首先要解决每个组件的定位问题，然后才能划分彼此的边界，实现合理的拆分。合就是根据最终要求，把各个分离的组件有机整合在一起。拆分的结果使开发人员能够做到业务聚焦、技能聚焦，实现开发敏捷，合的结果是系统变得柔性，可以因需而变，实现业务敏捷。 SOA和微服务架构SOA和微服务的区别其实服务化架构已经可以解决大部分企业的需求了，那么我们为什么要研究微服务呢？先说说它们的区别； 1.微服务架构强调业务系统需要彻底的组件化和服务化，一个组件就是一个产品，可以独立对外提供服务2.微服务不再强调传统SOA架构里面比较重的ESB企业服务总线3.微服务强调每个微服务都有自己独立的运行空间，包括数据库资源。4.微服务架构本身来源于互联网的思路，因此组件对外发布的服务强调了采用HTTP Rest API的方式来进行4.微服务的切分粒度会更小 总结:微服务架构是 SOA 架构思想的一种扩展，更加强调服务个体的独立性、拆分粒度更小。 为什么考虑Spring CloudSpring Cloud来源于Spring，质量、稳定性、持续性都可以得到保证 Spirng Cloud天然支持Spring Boot，更加便于业务落地。 Spring Cloud发展非常的快，从16年开始接触的时候相关组件版本为1.x，到现在将要发布2.x系列 Spring Cloud是Java领域最适合做微服务的框架。 相比于其它框架,Spring Cloud对微服务周边环境的支持力度最大。 对于中小企业来讲，使用门槛较低。 Spring Cloud 是微服务架构的最佳落地方案 Spring Cloud的特性以下为Spring Cloud的核心特性： 1.分布式/版本化配置2.服务注册和发现3.路由4.服务和服务之间的调用5.负载均衡6.断路器7.分布式消息传递 这些特性都是由不同的组件来完成，在架构的演进过程中扮演着重要的角色，接下来我们一起看看。 微服务架构Spring Cloud解决的第一个问题就是：服务与服务之间的解耦。很多公司在业务高速发展的时候，服务组件也会相应的不断增加。服务和服务之间有着复杂的相互调用关系，经常有服务A调用服务B，服务B调用服务C和服务D …，随着服务化组件的不断增多，服务之间的调用关系成指数级别的增长，极端情况下就如下图所示： 这样最容易导致的情况就是牵一发而动全身。经常出现由于某个服务更新而没有通知到其它服务，导致上线后惨案频发。这时候就应该进行服务治理，将服务之间的直接依赖转化为服务对服务中心的依赖。Spring Cloud 核心组件Eureka就是解决这类问题。 EurekaEureka是Netflix开源的一款提供服务注册和发现的产品，它提供了完整的Service Registry和Service Discovery实现。也是Spring Cloud体系中最重要最核心的组件之一。 用大白话讲，Eureka就是一个服务中心，将所有的可以提供的服务都注册到它这里来管理，其它各调用者需要的时候去注册中心获取，然后再进行调用，避免了服务之间的直接调用，方便后续的水平扩展、故障转移等。如下图： 当然服务中心这么重要的组件一但挂掉将会影响全部服务，因此需要搭建Eureka集群来保持高可用性，生产中建议最少两台。随着系统的流量不断增加，需要根据情况来扩展某个服务，Eureka内部已经提供均衡负载的功能，只需要增加相应的服务端实例既可。那么在系统的运行期间某个实例挂了怎么办？Eureka内容有一个心跳检测机制，如果某个实例在规定的时间内没有进行通讯则会自动被剔除掉，避免了某个实例挂掉而影响服务。 因此使用了Eureka就自动具有了注册中心、负载均衡、故障转移的功能。 Hystrix在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。 如下图所示：A作为服务提供者，B为A的服务消费者，C和D是B的服务消费者。A不可用引起了B的不可用，并将不可用像滚雪球一样放大到C和D时，雪崩效应就形成了。 在这种情况下就需要整个服务机构具有故障隔离的功能，避免某一个服务挂掉影响全局。在Spring Cloud 中Hystrix组件就扮演这个角色。 Hystrix会在某个服务连续调用N次不响应的情况下，立即通知调用端调用失败，避免调用端持续等待而影响了整体服务。Hystrix间隔时间会再次检查此服务，如果服务恢复将继续提供服务。 Hystrix Dashboard和Turbine当熔断发生的时候需要迅速的响应来解决问题，避免故障进一步扩散，那么对熔断的监控就变得非常重要。熔断的监控现在有两款工具：Hystrix-dashboard和Turbine Hystrix-dashboard是一款针对Hystrix进行实时监控的工具，通过Hystrix Dashboard我们可以直观地看到各Hystrix Command的请求响应时间, 请求成功率等数据。但是只使用Hystrix Dashboard的话, 你只能看到单个应用内的服务信息, 这明显不够. 我们需要一个工具能让我们汇总系统内多个服务的数据并显示到Hystrix Dashboard上, 这个工具就是Turbine. 监控的效果图如下： ###配置中心随着微服务不断的增多，每个微服务都有自己对应的配置文件。在研发过程中有测试环境、UAT环境、生产环境，因此每个微服务又对应至少三个不同环境的配置文件。这么多的配置文件，如果需要修改某个公共服务的配置信息，如：缓存、数据库等，难免会产生混乱，这个时候就需要引入Spring Cloud另外一个组件：Spring Cloud Config。 Spring Cloud ConfigSpring Cloud Config是一个解决分布式系统的配置管理方案。它包含了Client和Server两个部分，Server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，Client通过接口获取数据、并依据此数据初始化自己的应用。 其实就是Server端将所有的配置文件服务化，需要配置文件的服务实例去Config Server获取对应的数据。将所有的配置文件统一整理，避免了配置文件碎片化。 如果服务运行期间改变配置文件，服务是不会得到最新的配置信息，需要解决这个问题就需要引入Refresh。 当所有的配置文件都存储在配置中心的时候，配置中心就成为了一个非常重要的组件。如果配置中心出现问题将会导致灾难性的后果，因此在生产中建议对配置中心做集群，来支持配置中心高可用性。 Spring Cloud Bus上面的Refresh方案虽然可以解决单个微服务运行期间重载配置信息的问题，但是在真正的实践生产中，可能会有N多的服务需要更新配置，如果每次依靠手动Refresh将是一个巨大的工作量，这时候Spring Cloud提出了另外一个解决方案：Spring Cloud Bus Spring Cloud Bus通过轻量消息代理连接各个分布的节点。这会用在广播状态的变化（例如配置变化）或者其它的消息指令中。Spring Cloud Bus的一个核心思想是通过分布式的启动器对Spring Boot应用进行扩展，也可以用来建立一个或多个应用之间的通信频道。目前唯一实现的方式是用AMQP消息代理作为通道。 Spring Cloud Bus是轻量级的通讯组件，也可以用在其它类似的场景中。有了Spring Cloud Bus之后，当我们改变配置文件提交到版本库中时，会自动的触发对应实例的Refresh，具体的工作流程如下： 服务网关在微服务架构模式下，后端服务的实例数一般是动态的，对于客户端而言很难发现动态改变的服务实例的访问地址信息。因此在基于微服务的项目中为了简化前端的调用逻辑，通常会引入API Gateway作为轻量级网关，同时API Gateway中也会实现相关的认证逻辑从而简化内部服务之间相互调用的复杂度。 Spring Cloud体系中支持API Gateway落地的技术就是Zuul。Spring Cloud Zuul路由是微服务架构中不可或缺的一部分，提供动态路由，监控，弹性，安全等的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。 它的具体作用就是服务转发，接收并转发所有内外部的客户端调用。使用Zuul可以作为资源的统一访问入口，同时也可以在网关做一些权限校验等类似的功能。 链路跟踪随着服务的越来越多，对调用链的分析会越来越复杂，如服务之间的调用关系、某个请求对应的调用链、调用之间消费的时间等，对这些信息进行监控就成为一个问题。在实际的使用中我们需要监控服务和服务之间通讯的各项指标，这些数据将是我们改进系统架构的主要依据。因此分布式的链路跟踪就变的非常重要，Spring Cloud也给出了具体的解决方案：Spring Cloud Sleuth和Zipkin Spring Cloud Sleuth为服务之间调用提供链路追踪。通过Sleuth可以很清楚的了解到一个服务请求经过了哪些服务，每个服务处理花费了多长时间。从而让我们可以很方便的理清各微服务间的调用关系。 Zipkin是Twitter的一个开源项目，允许开发者收集 Twitter 各个服务上的监控数据，并提供查询接口 分布式链路跟踪需要Sleuth+Zipkin结合来实现. 总结我们从整体上来看一下Spring Cloud各个组件如何来配套使用： 从上图可以看出Spring Cloud各个组件相互配合，合作支持了一套完整的微服务架构。 其中Eureka负责服务的注册与发现，很好将各服务连接起来Hystrix 负责监控服务之间的调用情况，连续多次失败进行熔断保护。Hystrix dashboard,Turbine 负责监控 Hystrix的熔断情况，并给予图形化的展示Spring Cloud Config 提供了统一的配置中心服务当配置文件发生变化的时候，Spring Cloud Bus 负责通知各服务去获取最新的配置信息所有对外的请求和服务，我们都通过Zuul来进行转发，起到API网关的作用最后我们使用Sleuth+Zipkin将所有的请求数据记录下来，方便我们进行后续分析 Spring Cloud从设计之初就考虑了绝大多数互联网公司架构演化所需的功能，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等。这些功能都是以插拔的形式提供出来，方便我们系统架构演进的过程中，可以合理的选择需要的组件进行集成，从而在架构演进的过程中会更加平滑、顺利。 微服务架构是一种趋势，Spring Cloud提供了标准化的、全站式的技术方案，意义可能会堪比当前Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"传统架构","slug":"传统架构","permalink":"http://yoursite.com/tags/传统架构/"},{"name":"微服务架构","slug":"微服务架构","permalink":"http://yoursite.com/tags/微服务架构/"},{"name":"SOA","slug":"SOA","permalink":"http://yoursite.com/tags/SOA/"}]},{"title":"第二章、spring cloud服务注册中心eureka---服务提供与调用","slug":"SpringCloud/2","date":"2018-10-28T23:22:51.000Z","updated":"2018-12-13T08:23:48.472Z","comments":true,"path":"2018/10/28/SpringCloud/2/","link":"","permalink":"http://yoursite.com/2018/10/28/SpringCloud/2/","excerpt":"服务提供与调用==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud案例中有三个角色：服务注册中心、服务提供者、服务消费者，其中服务注册中心就是我们上一篇的eureka单机版启动既可，流程是首先启动注册中心，服务提供者生产服务并注册到服务中心中，消费者从服务中心中获取服务并执行。","text":"服务提供与调用==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud案例中有三个角色：服务注册中心、服务提供者、服务消费者，其中服务注册中心就是我们上一篇的eureka单机版启动既可，流程是首先启动注册中心，服务提供者生产服务并注册到服务中心中，消费者从服务中心中获取服务并执行。 1234graph LRC[Service&lt;br/&gt;Provider] --Register/Renew/Cancel--&gt;B[Eureka&lt;br/&gt;Server] A[Service&lt;br/&gt;Consumer] --Get Registry--&gt; B[Eureka&lt;br/&gt;Server] A[Service&lt;br/&gt;Consumer] --Remote Call--&gt; C[Service&lt;br/&gt;Provider] 02eureka-producer-consumer: 0201spring-cloud-eureka : 0202spring-cloud-producer-two&lt;服务提供者two 端口：9000&gt;[1、spring cloud服务注册中心eureka—服务提供者(第二章)]: 0203spring-cloud-producer-one&lt;服务提供者one 端口：9001&gt;: 0204spring-cloud-consumer-one&lt;服务消费者one 端口：9091&gt;[2、spring cloud服务注册中心eureka—服务消费者(第二章)]: 0205spring-cloud-consumer-two&lt;服务消费者two 端口：9092&gt;[3、spring cloud服务注册中心eureka—基于feign的负载均衡(第二章)] 在(01spring-cloud-eureka)我们介绍了eureka服务注册中心的搭建，这篇文章介绍一下如何使用eureka服务注册中心，搭建一个简单的服务端注册服务，客户端去调用服务使用的案例以及基于feign的负载均衡。 示例代码-码云 https://gitee.com/sharps/springcloud","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"eureka","slug":"eureka","permalink":"http://yoursite.com/tags/eureka/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"http://yoursite.com/tags/spring-cloud/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/tags/spring-boot/"}]},{"title":"第一章、spring cloud服务注册中心eureka---概念","slug":"SpringCloud/1","date":"2018-10-28T11:12:37.000Z","updated":"2018-12-13T08:19:25.815Z","comments":true,"path":"2018/10/28/SpringCloud/1/","link":"","permalink":"http://yoursite.com/2018/10/28/SpringCloud/1/","excerpt":"注册中心Eureka==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud 背景介绍服务中心","text":"注册中心Eureka==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud 背景介绍服务中心 服务中心又称注册中心，管理各种服务功能包括服务的注册、发现、熔断、负载、降级等，比如dubbo admin后台的各种功能。有了服务中心调用关系会有什么变化，画几个简图来帮忙理解项目A调用项目B正常调用项目A请求项目B 12graph LRA[项目A] -- 请求 --&gt; B[项目B] 有了服务中心之后，任何一个服务都不能直接去掉用，都需要通过服务中心来调用 123graph LRA[项目A] --&gt; C(服&lt;br/&gt;务&lt;br/&gt;中&lt;br/&gt;心) C--&gt; B[项目B] 这时候调用的步骤就会为两步：第一步，项目A首先从服务中心请求项目B服务器，然后项目B在从服务中心请求项目C服务。 12345graph LRA[项目A] --&gt; D(服&lt;br/&gt;&lt;br/&gt;务&lt;br/&gt;&lt;br/&gt;中&lt;br/&gt;&lt;br/&gt;心) D--&gt; C[项目B] B[项目B] --&gt;DD--&gt;E[项目C] 上面的项目只是两三个相互之间的简单调用，但是如果项目超过20个30个呢，画一张图来描述几十个项目之间的相互调用关系全是线条，任何其中的一个项目改动，就会牵连好几个项目跟着重启，巨麻烦而且容易出错。通过服务中心来获取服务你不需要关注你调用的项目IP地址，由几台服务器组成，每次直接去服务中心获取可以使用的服务去调用既可。由于各种服务都注册到了服务中心，就有了去做很多高级功能条件。比如几台服务提供相同服务来做均衡负载；监控服务器调用成功率来做熔断，移除服务列表中的故障点；监控服务调用时间来对不同的服务器设置不同的权重等等。 Eureka按照官方介绍： Eureka is a REST (Representational State Transfer) based service that is primarily used in the AWS cloud for locating services for the purpose of load balancing and failover of middle-tier servers. Eureka 是一个基于 REST 的服务，主要在 AWS 云中使用, 定位服务来进行中间层服务器的负载均衡和故障转移。 Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务注册和发现。Eureka 采用了 C-S 的设计架构。Eureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka 的客户端连接到 Eureka Server，并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。Spring Cloud 的一些其他模块（比如Zuul）就可以通过 Eureka Server 来发现系统中的其他微服务，并执行相关的逻辑。 Eureka由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。 用一张图来认识以下： 1234graph LRC[Service&lt;br/&gt;Provider] --Register/Renew/Cancel--&gt;B[Eureka&lt;br/&gt;Server] A[Service&lt;br/&gt;Consumer] --Get Registry--&gt; B[Eureka&lt;br/&gt;Server] A[Service&lt;br/&gt;Consumer] --Remote Call--&gt; C[Service&lt;br/&gt;Provider] 上图简要描述了Eureka的基本架构，由3个角色组成：1、Eureka Server提供服务注册和发现2、Service Provider服务提供方将自身服务注册到Eureka，从而使服务消费方能够找到3、Service Consumer服务消费方从Eureka获取注册服务列表，从而能够消费服务 项目节点01spring-cloud-eureka—-&gt;0101spring-cloud-eureka 说明：服务注册中心eureka配置 1、spring cloud服务注册中心eureka—单节点配置(第一章)—-&gt;0102spring-cloud-eureka-two 说明：服务注册中心eureka配置 2、spring cloud服务注册中心eureka—双节点配置(第一章)—-&gt;0103spring-cloud-eureka-cluster 说明：服务注册中心eureka配置 3、spring cloud服务注册中心eureka—集群配置(第一章) 示例代码-码云 https://gitee.com/sharps/springcloud","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"eureka","slug":"eureka","permalink":"http://yoursite.com/tags/eureka/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"http://yoursite.com/tags/spring-cloud/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/tags/spring-boot/"}]},{"title":"第一章：第一节spring cloud服务注册中心eureka---单节点配置","slug":"SpringCloud/1-1","date":"2018-10-28T11:12:36.000Z","updated":"2018-12-13T08:19:25.815Z","comments":true,"path":"2018/10/28/SpringCloud/1-1/","link":"","permalink":"http://yoursite.com/2018/10/28/SpringCloud/1-1/","excerpt":"Eureka Server—单节点配置==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloudspring cloud已经帮我实现了服务注册中心，我们只需要很简单的几个步骤就可以完成。","text":"Eureka Server—单节点配置==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloudspring cloud已经帮我实现了服务注册中心，我们只需要很简单的几个步骤就可以完成。1、pom中添加依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.llx.springcloud&lt;/groupId&gt; &lt;artifactId&gt;eurekaserver&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-cloud-eureka&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.M1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 2、添加启动代码中添加@EnableEurekaServer注解1234567@SpringBootApplication@EnableEurekaServerpublic class SpringCloudEurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringCloudEurekaApplication.class, args); &#125;&#125; 3、配置文件在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，在application.properties添加以下配置：12345678spring.application.name=spring-cloud-eurekaserver.port=8000#表示是否将自己注册到Eureka Server，默认为true。eureka.client.register-with-eureka=false#表示是否从Eureka Server获取注册信息，默认为true。eureka.client.fetch-registry=false#设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址。默认是http://localhost:8761/eureka ；多个地址可使用 , 分隔。eureka.client.serviceUrl.defaultZone=http://localhost:$&#123;server.port&#125;/eureka/ eureka.client.register-with-eureka ：表示是否将自己注册到Eureka Server，默认为true。eureka.client.fetch-registry ：表示是否从Eureka Server获取注册信息，默认为true。eureka.client.serviceUrl.defaultZone ：设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址。默认是http://localhost:8761/eureka ；多个地址可使用” , “分隔。启动工程后，访问：http://localhost:8000/ 可以看到的页面，其中还没有发现任何服务.","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"eureka","slug":"eureka","permalink":"http://yoursite.com/tags/eureka/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"http://yoursite.com/tags/spring-cloud/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/tags/spring-boot/"}]},{"title":"第一章：第二节spring cloud服务注册中心eureka—双节点配置","slug":"SpringCloud/1-2","date":"2018-10-28T11:12:35.000Z","updated":"2018-12-13T08:19:25.815Z","comments":true,"path":"2018/10/28/SpringCloud/1-2/","link":"","permalink":"http://yoursite.com/2018/10/28/SpringCloud/1-2/","excerpt":"集群==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud注册中心这么关键的服务，如果是单点话，遇到故障就是毁灭性的。在一个分布式系统中，服务注册中心是最重要的基础部分，理应随时处于可以提供服务的状态。为了维持其可用性，使用集群是很好的解决方案。Eureka通过互相注册的方式来实现高可用的部署，所以我们只需要将Eureke Server配置其他可用的serviceUrl就能实现高可用部署。","text":"集群==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud注册中心这么关键的服务，如果是单点话，遇到故障就是毁灭性的。在一个分布式系统中，服务注册中心是最重要的基础部分，理应随时处于可以提供服务的状态。为了维持其可用性，使用集群是很好的解决方案。Eureka通过互相注册的方式来实现高可用的部署，所以我们只需要将Eureke Server配置其他可用的serviceUrl就能实现高可用部署。 双节点注册中心首次我们尝试一下双节点的注册中心的搭建。 1、创建application-peer1.properties，作为peer1服务中心的配置，并将serviceUrl指向peer21234spring.application.name=spring-cloud-eurekaserver.port=8000eureka.instance.hostname=peer1eureka.client.serviceUrl.defaultZone=http://peer2:8001/eureka/ 2、创建application-peer2.properties，作为peer2服务中心的配置，并将serviceUrl指向peer11234spring.application.name=spring-cloud-eurekaserver.port=8001eureka.instance.hostname=peer2eureka.client.serviceUrl.defaultZone=http://peer1:8000/eureka/ 3、host转换/etc/hosts在hosts文件中加入如下配置12127.0.0.1 peer1 127.0.0.1 peer2 4、打包启动 依次执行下面命令 打包1mvn clean package # 分别以peer1和peer2 配置信息启动eureka12java -jar spring-cloud-eureka-two-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1java -jar spring-cloud-eureka-two-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2 依次启动完成后，浏览器输入：http://localhost:8000/ 可以看出peer1的注册中心DS Replicas已经有了peer2的相关配置信息，并且出现在available-replicas中。我们手动停止peer2来观察，发现peer2就会移动到unavailable-replicas一栏中，表示peer2不可用。 到此双节点的配置已经完成。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"eureka","slug":"eureka","permalink":"http://yoursite.com/tags/eureka/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"http://yoursite.com/tags/spring-cloud/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/tags/spring-boot/"}]},{"title":"第二章：第三节spring cloud服务注册中心eureka---集群配置","slug":"SpringCloud/1-3","date":"2018-10-28T11:12:34.000Z","updated":"2018-12-13T08:19:25.815Z","comments":true,"path":"2018/10/28/SpringCloud/1-3/","link":"","permalink":"http://yoursite.com/2018/10/28/SpringCloud/1-3/","excerpt":"**eureka集群配置==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud 在生产中我们可能需要三台或者大于三台的注册中心来保证服务的稳定性，配置的原理其实都一样，将注册中心分别指向其它的注册中心。这里只介绍三台集群的配置情况，其实和双节点的注册中心类似，每台注册中心分别又指向其它两个节点即可，使用application.yml来配置。","text":"**eureka集群配置==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud 在生产中我们可能需要三台或者大于三台的注册中心来保证服务的稳定性，配置的原理其实都一样，将注册中心分别指向其它的注册中心。这里只介绍三台集群的配置情况，其实和双节点的注册中心类似，每台注册中心分别又指向其它两个节点即可，使用application.yml来配置。application.yml配置详情如下：1234567891011121314151617181920212223242526272829303132333435363738spring: application: name: spring-cloud-eureka profiles: peer1server: port: 8000eureka: instance: hostname: peer1 client: serviceUrl: defaultZone: http://peer2:8001/eureka/,http://peer3:8002/eureka/spring: application: name: spring-cloud-eureka profiles: peer2server: port: 8001eureka: instance: hostname: peer2 client: serviceUrl: defaultZone: http://peer1:8000/eureka/,http://peer3:8002/eureka/spring: application: name: spring-cloud-eureka profiles: peer3server: port: 8002eureka: instance: hostname: peer3 client: serviceUrl: defaultZone: http://peer1:8000/eureka/,http://peer2:8001/eureka/ 分别以peer1、peer2、peer3的配置参数启动eureka注册中心。123java -jar spring-cloud-eureka-cluster-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1java -jar spring-cloud-eureka-cluster-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2java -jar spring-cloud-eureka-cluster-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer3 依次启动完成后，浏览器输入：http://localhost:8000/可以在peer1中看到了peer2、peer3的相关信息。至此eureka集群也已经完成了","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"eureka","slug":"eureka","permalink":"http://yoursite.com/tags/eureka/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"http://yoursite.com/tags/spring-cloud/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/tags/spring-boot/"}]},{"title":"第二章:第一节spring cloud服务注册中心eureka---服务提供者","slug":"SpringCloud/2-1","date":"2018-10-28T09:12:37.000Z","updated":"2018-12-13T08:19:25.815Z","comments":true,"path":"2018/10/28/SpringCloud/2-1/","link":"","permalink":"http://yoursite.com/2018/10/28/SpringCloud/2-1/","excerpt":"**服务提供==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud我们假设服务提供者有一个hello方法，可以根据传入的参数，提供输出“hello xxx，this is first messge”的服务","text":"**服务提供==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud我们假设服务提供者有一个hello方法，可以根据传入的参数，提供输出“hello xxx，this is first messge”的服务1、pom包配置创建一个springboot项目，pom.xml中添加如下配置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.llx.springcloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-producer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-cloud-producer&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.M1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 2、配置文件application.properties配置如下： 123spring.application.name=spring-cloud-producer-oneserver.port=9001eureka.client.serviceUrl.defaultZone=http://localhost:8888/eureka/ 参数在上一篇都已经解释过，这里不多说。 3、启动类启动类中添加@EnableDiscoveryClient注解12345678@SpringBootApplication@EnableDiscoveryClientpublic class ProducerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProducerApplication.class, args); &#125;&#125; 4、controller提供hello服务12345678@RestControllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String index(@RequestParam String name) &#123; return \"hello \"+name+\"，this is first messge\"; &#125;&#125; 添加@EnableDiscoveryClient注解后，项目就具有了服务注册的功能。启动工程后，就可以在注册中心的页面看到SPRING-CLOUD-PRODUCER-ONE服务。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"eureka","slug":"eureka","permalink":"http://yoursite.com/tags/eureka/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"http://yoursite.com/tags/spring-cloud/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/tags/spring-boot/"},{"name":"服务提供者","slug":"服务提供者","permalink":"http://yoursite.com/tags/服务提供者/"},{"name":"producer","slug":"producer","permalink":"http://yoursite.com/tags/producer/"}]},{"title":"第二章：第二节spring cloud服务注册中心eureka---服务消费者","slug":"SpringCloud/2-2","date":"2018-10-28T08:12:37.000Z","updated":"2018-12-13T08:19:25.815Z","comments":true,"path":"2018/10/28/SpringCloud/2-2/","link":"","permalink":"http://yoursite.com/2018/10/28/SpringCloud/2-2/","excerpt":"**服务调用==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud1、pom包配置和服务提供者一致","text":"**服务调用==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud1、pom包配置和服务提供者一致12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.llx.springcloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-consumer&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-cloud-consumer&lt;/name&gt; &lt;description&gt;Demo spring-cloud-consumer&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.M1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;--&gt; &lt;!--&lt;/dependency&gt;--&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 2、配置文件application.properties配置如下：123spring.application.name=spring-cloud-consumerserver.port=9091eureka.client.serviceUrl.defaultZone=http://localhost:8888/eureka/ 3、启动类启动类添加@EnableDiscoveryClient和@EnableFeignClients注解。12345678910@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConsumerApplication.class, args); &#125;&#125; @EnableDiscoveryClient :启用服务注册与发现@EnableFeignClients：启用feign进行远程调用Feign是一个声明式Web Service客户端。使用Feign能让编写Web Service客户端更加简单, 它的使用方法是定义一个接口，然后在上面添加注解，同时也支持JAX-RS标准的注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡。 4、feign调用实现12345@FeignClient(name= \"spring-cloud-producer\")public interface HelloRemote &#123; @RequestMapping(value = \"/hello\") public String hello(@RequestParam(value = \"name\") String name);&#125; name:远程服务名，及spring.application.name配置的名称此类中的方法和远程服务中contoller中的方法名和参数需保持一致。 5、web层调用远程服务将HelloRemote注入到controller层，像普通方法一样去调用即可。123456789101112@RestControllerpublic class ConsumerController &#123; @Autowired HelloRemote HelloRemote; @RequestMapping(\"/hello/&#123;name&#125;\") public String index(@PathVariable(\"name\") String name) &#123; return HelloRemote.hello(name); &#125;&#125; 到此，最简单的一个服务注册与调用的例子就完成了。 ####测试简单调用依次启动spring-cloud-eureka、spring-cloud-producer、spring-cloud-consumer三个项目 先输入：http://localhost:9000/hello?name=llx 检查spring-cloud-producer服务是否正常 返回：hello llx，this is first messge 说明spring-cloud-producer正常启动，提供的服务也正常。 浏览器中输入：http://localhost:9091/hello/llx 返回：hello llx，this is first messge 说明客户端已经成功的通过feign调用了远程服务hello，并且将结果返回到了浏览器。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"eureka","slug":"eureka","permalink":"http://yoursite.com/tags/eureka/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"http://yoursite.com/tags/spring-cloud/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/tags/spring-boot/"}]},{"title":"第二章：第三节spring cloud服务注册中心eureka---基于feign的负载均衡","slug":"SpringCloud/2-3","date":"2018-10-28T07:13:37.000Z","updated":"2018-12-13T08:19:25.815Z","comments":true,"path":"2018/10/28/SpringCloud/2-3/","link":"","permalink":"http://yoursite.com/2018/10/28/SpringCloud/2-3/","excerpt":"**基于feign的负载均衡==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud spring-cloud-producer-one修改，将其中的controller改动如下：","text":"**基于feign的负载均衡==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud spring-cloud-producer-one修改，将其中的controller改动如下：12345678@RestControllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String index(@RequestParam String name) &#123; return return \"test1:hello\"+name+\"this is first message!\";; &#125;&#125; spring-cloud-producer-two修改，将其中的controller改动如下：12345678@RestControllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String index(@RequestParam String name) &#123; return return \"test2:hello\"+name+\"this is first message!\";; &#125;&#125; spring-cloud-producer-one 、spring-cloud-producer-two 修改，将其中的remote改动 都修改为 @FeignClient(name=”spring-cloud-producer”)123456@FeignClient(name=\"spring-cloud-producer\")public interface HelloRemote &#123; @RequestMapping(value = \"/hello\") String hello(@RequestParam(value = \"name\") String name);&#125; 在配置文件中改动端口：spring-cloud-producer-one 、spring-cloud-producer-two 修改，将其中的application.properties 都改动为 spring.application.name=spring-cloud-producer 在eureka就会发现两个服务提供者， 然后在浏览器再次输入：http://localhost:9091/hello/llx 进行测试： 第一次返回结果：test1:hello llx this is first message! 第二次返回结果：test2:hello llx this is first message! 不断的进行测试下去会发现两种结果交替出现，说明两个服务中心自动提供了服务均衡负载的功能。如果我们将服务提供者的数量在提高为N个，测试结果一样，请求会自动轮询到每个服务端来处理。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"eureka","slug":"eureka","permalink":"http://yoursite.com/tags/eureka/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"http://yoursite.com/tags/spring-cloud/"},{"name":"feign","slug":"feign","permalink":"http://yoursite.com/tags/feign/"},{"name":"负载均衡","slug":"负载均衡","permalink":"http://yoursite.com/tags/负载均衡/"}]},{"title":"第三章、spring cloud服务注册中心eureka---服务提供与调用","slug":"SpringCloud/3","date":"2018-10-26T12:12:57.000Z","updated":"2018-12-13T08:19:25.815Z","comments":true,"path":"2018/10/26/SpringCloud/3/","link":"","permalink":"http://yoursite.com/2018/10/26/SpringCloud/3/","excerpt":"服务提供与调用==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud案例中有三个角色：服务注册中心、服务提供者、服务消费者，其中服务注册中心就是我们上一篇的eureka单机版启动既可，流程是首先启动注册中心，服务提供者生产服务并注册到服务中心中，消费者从服务中心中获取服务并执行。","text":"服务提供与调用==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud案例中有三个角色：服务注册中心、服务提供者、服务消费者，其中服务注册中心就是我们上一篇的eureka单机版启动既可，流程是首先启动注册中心，服务提供者生产服务并注册到服务中心中，消费者从服务中心中获取服务并执行。 1234graph LRC[Service&lt;br/&gt;Provider] --Register/Renew/Cancel--&gt;B[Eureka&lt;br/&gt;Server] A[Service&lt;br/&gt;Consumer] --Get Registry--&gt; B[Eureka&lt;br/&gt;Server] A[Service&lt;br/&gt;Consumer] --Remote Call--&gt; C[Service&lt;br/&gt;Provider] 02eureka-producer-consumer: 0201spring-cloud-eureka : 0202spring-cloud-producer-two&lt;服务提供者two 端口：9000&gt;[1、spring cloud服务注册中心eureka—服务提供者(第二章)]: 0203spring-cloud-producer-one&lt;服务提供者one 端口：9001&gt;: 0204spring-cloud-consumer-one&lt;服务消费者one 端口：9091&gt;[2、spring cloud服务注册中心eureka—服务消费者(第二章)]: 0205spring-cloud-consumer-two&lt;服务消费者two 端口：9092&gt;[3、spring cloud服务注册中心eureka—基于feign的负载均衡(第二章)] 在(01spring-cloud-eureka)我们介绍了eureka服务注册中心的搭建，这篇文章介绍一下如何使用eureka服务注册中心，搭建一个简单的服务端注册服务，客户端去调用服务使用的案例以及基于feign的负载均衡。 示例代码-码云 https://gitee.com/sharps/springcloud","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"eureka","slug":"eureka","permalink":"http://yoursite.com/tags/eureka/"},{"name":"spring cloud","slug":"spring-cloud","permalink":"http://yoursite.com/tags/spring-cloud/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://yoursite.com/tags/spring-boot/"}]},{"title":"第三章：第一节spring cloud---feign+Hystrix熔断器实现","slug":"SpringCloud/3-1","date":"2018-10-26T11:12:57.000Z","updated":"2018-12-13T08:39:18.164Z","comments":true,"path":"2018/10/26/SpringCloud/3-1/","link":"","permalink":"http://yoursite.com/2018/10/26/SpringCloud/3-1/","excerpt":"** Feign-Hystrix==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud 因为熔断只是作用在服务调用这一端，因此我们根据上一篇的示例代码只需要改动spring-cloud-consumer项目相关代码就可以。因为，Feign中已经依赖了Hystrix所以在maven配置上不用做任何改动。","text":"** Feign-Hystrix==本文中示例代码的引用版本：org.springframework.boot 版本 ：2.1.0.RELEASEorg.springframework.cloud 版本：Greenwich.M1==示例代码-码云 https://gitee.com/sharps/springcloud 因为熔断只是作用在服务调用这一端，因此我们根据上一篇的示例代码只需要改动spring-cloud-consumer项目相关代码就可以。因为，Feign中已经依赖了Hystrix所以在maven配置上不用做任何改动。1、配置文件application.properties添加这一条：1feign.hystrix.enabled=true 2、创建回调类创建HelloRemoteHystrix类继承与HelloRemote实现回调的方法 12345678@Componentpublic class HelloRemoteHystrix implements HelloRemote&#123; @Override public String hello(@RequestParam(value = \"name\") String name) &#123; return \"hello\" +name+\", this messge send failed \"; &#125;&#125; 3、添加fallback属性在HelloRemote类添加指定fallback类，在服务熔断的时候返回fallback类中的内容。1234567@FeignClient(name= \"spring-cloud-producer\",fallback = HelloRemoteHystrix.class)public interface HelloRemote &#123; @RequestMapping(value = \"/hello\") public String hello(@RequestParam(value = \"name\") String name);&#125; 改动点就这点，很简单吧。 4、测试那我们就来测试一下看看效果吧。 依次启动0301spring-cloud-eureka、0302spring-cloud-producer、0303spring-cloud-consumer-hystrix三个项目。 浏览器中输入：http://localhost:9091/hello/llx 返回：hello llx，this is first messge! 说明加入熔断相关信息后，不影响正常的访问。接下来我们手动停止spring-cloud-producer项目再次测试： 浏览器中输入：http://localhost:9091/hello/llx 返回：hello llx, this messge send failed! 根据返回结果说明熔断成功。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"feign","slug":"feign","permalink":"http://yoursite.com/tags/feign/"},{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"},{"name":"Hystrix","slug":"Hystrix","permalink":"http://yoursite.com/tags/Hystrix/"}]}]}